import crypto from "crypto";
import {
  FormationEventInput,
  FormationEventType,
  FormationStage,
  applyFormationDefaults,
  validateFormationEvent,
} from "./phase3_1_scope";
import { getFormationEventsTableClient, getFormationProfilesTableClient } from "../../storage/formation/formationTables";
import { FormationEventEntity, insertFormationEvent } from "../../storage/formation/formationEventsRepo";
import {
  FormationProfileEntity,
  createDefaultFormationProfile,
  getFormationProfile,
  upsertFormationProfile,
} from "../../storage/formation/formationProfilesRepo";
import { ensureTableExists } from "../../shared/storage/ensureTableExists";
import { updateFormationProfileFromEvent } from "./updateFormationProfileFromEvent";


/**
 * Formation event recorder (Phase 3)
 * - Append-only events
 * - Snapshot updates on FormationProfile
 * - Deterministic, non-downgrading stage progression
 */

export type RecordFormationEventDeps = {
  storageConnectionString: string;
  ensureVisitorExists?: (visitorId: string) => Promise<void>;
};

export type RecordFormationEventResult = {
  eventRowKey: string;
  profile: FormationProfileEntity;
};

function nowIso() {
  return new Date().toISOString();
}

function makeRowKey(occurredAtIso: string) {
  const suffix = crypto.randomBytes(6).toString("hex");
  return `${occurredAtIso}__${suffix}`;
}

function stringifyMetadata(metadata: unknown): string | undefined {
  if (metadata == null) return undefined;
  return JSON.stringify(metadata);
}

/**
 * Stage progression rules (PILOT)
 * Valid stages: Visitor | Guest | Connected
 * - Never downgrade
 * - FOLLOWUP_CONTACTED does NOT advance stage
 * - NEXT_STEP_SELECTED advances to Connected
 * - FOLLOWUP_OUTCOME_RECORDED advances to Connected for positive outcomes
 */
const STAGE_RANK: Record<FormationStage, number> = {
  Visitor: 0,
  Guest: 1,
  Connected: 2,
};

function normalizeStage(value: unknown): FormationStage {
  const s = String(value ?? "").trim();
  return s === "Visitor" || s === "Guest" || s === "Connected"
    ? (s as FormationStage)
    : "Visitor";
}

function maxStage(a: FormationStage, b: FormationStage): FormationStage {
  return STAGE_RANK[a] >= STAGE_RANK[b] ? a : b;
}

function computeNextStage(
  currentStage: unknown,
  eventType: string,
  metadata: any
): FormationStage {
  const current = normalizeStage(currentStage);

  switch (eventType) {
    case FormationEventType.FOLLOWUP_ASSIGNED:
      // When staff takes ownership, treat as an active Guest (no downgrade)
      return maxStage(current, "Guest");
    case FormationEventType.NEXT_STEP_SELECTED:
      return maxStage(current, "Connected");

    case FormationEventType.FOLLOWUP_OUTCOME_RECORDED: {
      const outcome = String(metadata?.outcome ?? "").toUpperCase().trim();
      const CONNECTED_OUTCOMES = new Set([
        "CONNECTED",
        "WILL_VISIT",
        "VISITING",
        "ATTENDING",
        "NEXT_STEP_TAKEN",
        "JOINED_GROUP",
        "MEMBER_CLASS",
        "BAPTISM_CLASS",
      ]);
      return CONNECTED_OUTCOMES.has(outcome)
        ? maxStage(current, "Connected")
        : current;
    }

    default:
      return current;
  }
}

function applyProfileTouchpoint(
  profile: FormationProfileEntity,
  type: string,
  occurredAt: string,
  metadata: any
) {
  switch (type) {
    case FormationEventType.SERVICE_ATTENDED:
      profile.lastServiceAttendedAt = occurredAt;
      break;

    case FormationEventType.FOLLOWUP_ASSIGNED:
      profile.lastFollowupAssignedAt = occurredAt;
      if (metadata?.assigneeId) profile.assignedTo = String(metadata.assigneeId);
      break;

    case FormationEventType.FOLLOWUP_CONTACTED:
      profile.lastFollowupContactedAt = occurredAt;
      break;

    case FormationEventType.NEXT_STEP_SELECTED:
    case FormationEventType.INFO_REQUESTED:
      profile.lastNextStepAt = occurredAt;
      break;

    case FormationEventType.PRAYER_REQUESTED:
      profile.lastPrayerRequestedAt = occurredAt;
      break;

    default:
      break;
  }

  // Stage progression (deterministic, no downgrade)
  const nextStage = computeNextStage(profile.stage, String(type ?? ""), metadata);
  if (nextStage !== profile.stage) {
    profile.stage = nextStage;
    (profile as any).stageUpdatedAt = occurredAt;
    (profile as any).stageUpdatedBy = "system";
    (profile as any).stageReason = `event:${String(type ?? "")}`;
  }
}

export async function recordFormationEvent(
  input: FormationEventInput,
  deps: RecordFormationEventDeps
): Promise<RecordFormationEventResult> {
  const valid = validateFormationEvent(input);
  if (!valid.ok) {
    const err = new Error(valid.error);
    (err as any).statusCode = 400;
    throw err;
  }

  if (deps.ensureVisitorExists) {
    await deps.ensureVisitorExists(input.visitorId);
  }

  const occurredAt = input.occurredAt ?? nowIso();
  const recordedAt = nowIso();
  const defaults = applyFormationDefaults(input);

  const eventsTable = getFormationEventsTableClient(deps.storageConnectionString);
  const profilesTable = getFormationProfilesTableClient(deps.storageConnectionString);
  await ensureTableExists(eventsTable);
  await ensureTableExists(profilesTable);

  let profile = await getFormationProfile(profilesTable, input.visitorId);
  if (!profile) {
    profile = createDefaultFormationProfile(input.visitorId);
  }

  const rowKey = makeRowKey(occurredAt);

  const eventEntity: FormationEventEntity = {
    partitionKey: input.visitorId,
    rowKey,
    visitorId: input.visitorId,
    type: input.type,
    occurredAt,
    recordedAt,
    channel: input.channel ?? defaults.channel,
    visibility: input.visibility ?? defaults.visibility,
    sensitivity: input.sensitivity ?? defaults.sensitivity,
    summary: input.summary,
    metadata: stringifyMetadata(input.metadata),
    idempotencyKey: input.idempotencyKey,
  };

  await insertFormationEvent(eventsTable, eventEntity);

  applyProfileTouchpoint(profile, input.type, occurredAt, input.metadata);

  await upsertFormationProfile(profilesTable, profile);

  return { eventRowKey: rowKey, profile };
}




